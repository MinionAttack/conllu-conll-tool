# -*- coding: utf-8 -*-

from io import StringIO
from pathlib import Path
from re import search
from typing import List, Tuple, Dict

from scipy.stats import ttest_ind

from modules.conll18_ud_eval import load_conllu, evaluate


def walk_directories(gold_a_path: Path, predicted_a_path: Path, gold_b_path: Path, predicted_b_path: Path) -> None:
    print("INFO: Browsing through directories to calculate the T-Test")

    gold_pattern = '\\-test\\.conll$'
    predited_pattern = '\\-predicted-test\\.conll$'

    gold_a_files = walk_directory(gold_a_path, gold_pattern)
    predicted_a_files = walk_directory(predicted_a_path, predited_pattern)
    gold_b_files = walk_directory(gold_b_path, gold_pattern)
    predicted_b_files = walk_directory(predicted_b_path, predited_pattern)

    parser_a_values = (gold_a_files, predicted_a_files)
    parser_b_values = (gold_b_files, predicted_b_files)
    ttest(parser_a_values, parser_b_values)


def walk_directory(files_path: Path, file_pattern: str) -> List[List[Path]]:
    print(f"INFO: Browsing through directories of {files_path.stem} to find {file_pattern} pattern")

    all_files = []
    files_root_folder = []

    for item in files_path.glob("*"):
        directory_group = []
        if item.is_dir() and not item.name.startswith('.'):
            for element in item.iterdir():
                if element.is_file() and search(file_pattern, element.name) is not None:
                    directory_group.append(element)
            if directory_group:
                directory_group.sort()
                all_files.append(directory_group)
        elif item.is_file() and not item.name.startswith('.') and search(file_pattern, item.name) is not None:
            files_root_folder.append(item)
        else:
            continue
    if files_root_folder:
        files_root_folder.sort()
        all_files.append(files_root_folder)

    all_files.sort()

    return all_files


def ttest(parser_a_values: Tuple[List[List[Path]], List[List[Path]]], parser_b_values: Tuple[List[List[Path]], List[List[Path]]]) -> None:
    print("INFO: Processing the data for the T-Test")

    parser_a_uas_las_values = process_parser_files(parser_a_values)
    parser_b_uas_las_values = process_parser_files(parser_b_values)
    calculate_ttest_value(parser_a_uas_las_values, parser_b_uas_las_values)


def process_parser_files(parser_values: Tuple[List[List[Path]], List[List[Path]]]) -> Dict[str, Dict[str, Tuple[List[float], List[float]]]]:
    print(f"INFO: Processing the parser files")

    gold_groups, predicted_groups = parser_values
    # Only one GOLD file per language is expected. For the predicted files of each language
    # it is possible to pass several files generated by different models.
    language_values = {}
    for gold_group, predicted_group in zip(gold_groups, predicted_groups):
        gold_file = gold_group[0]
        gold_language = gold_file.parent.name
        predicted_language = predicted_group[0].parent.name

        if gold_language == predicted_language:
            models_values = {}
            for predicted_file in predicted_group:
                gold_list = file_to_list(gold_file)
                predicted_list = file_to_list(predicted_file)
                uas_values, las_values = get_uas_las_values(gold_language, gold_list, predicted_list)
                models_values[predicted_file.stem] = (uas_values, las_values)

            language_values[gold_language] = models_values
        else:
            print(f"Error: Gold language ({gold_language}) does not match with predicted language ({predicted_language})")

    return language_values


def file_to_list(test_file: Path) -> List[str]:
    print(f"INFO: Converting the file {test_file.name} into a list")

    with open(test_file) as file:
        sentences = file.read().split('\n\n')

    return sentences


def get_uas_las_values(language: str, gold_list: List[str], predicted_list: List[str]) -> Tuple[List[float], List[float]]:
    print(f"INFO: Calculating the UAS and LAS values for each sentence in language {language}")

    uas_values = []
    las_values = []
    for gold_sentence, predicted_sentence in zip(gold_list, predicted_list):
        gold_temp = StringIO(gold_sentence + '\n\n')
        predicted_temp = StringIO(predicted_sentence + '\n\n')
        gold_ud = load_conllu(gold_temp)
        output_ud = load_conllu(predicted_temp)
        score = evaluate(gold_ud, output_ud)
        uas = score['UAS'].f1 * 100
        las = score['LAS'].f1 * 100
        uas_values.append(uas)
        las_values.append(las)

    return uas_values, las_values


def calculate_ttest_value(parser_a_uas_las_values: Dict[str, Dict[str, Tuple[List[float], List[float]]]],
                          parser_b_uas_las_values: Dict[str, Dict[str, Tuple[List[float], List[float]]]]) -> None:
    print(f"INFO: Calculating the T-test values")

    for (language_a, predicted_a), (language_b, predicted_b) in zip(parser_a_uas_las_values.items(), parser_b_uas_las_values.items()):
        if language_a == language_b:
            if len(predicted_a) == len(predicted_b):
                print_header(language_a, 95)
                index = 1
                for sentences_a, sentences_b in zip(predicted_a.values(), predicted_b.values()):
                    parser_a_uas, parser_a_las = sentences_a
                    parser_b_uas, parser_b_las = sentences_b
                    tstatistic_uas, pvalue_uas = ttest_ind(parser_a_uas, parser_b_uas)
                    tstatistic_las, pvalue_las = ttest_ind(parser_a_las, parser_b_las)
                    print(
                        f"(#{index}) t-statistic UAS: {tstatistic_uas:.2f}\tp-value UAS: {pvalue_uas:.2f}\t|\t(#{index}) t-statistic LAS: "
                        f"{tstatistic_las:.2f}\tp-value LAS: {pvalue_las:.2f}")
                    index += 1
            else:
                print(f"ERROR: Only parsers with the same number of predicted files can be compared. Parser A ({len(predicted_a)} files) "
                      f"vs. Parser B ({len(predicted_b)} files)")
        else:
            print(f"ERROR: The languages do not match, {language_a} vs. {language_b}. Check that both parsers have the same set of "
                  f"languages to compare.")


def print_header(language: str, row_length: int) -> None:
    letters = len(language)
    separation = 2  # A separation space for each side
    side_length = (row_length - letters - separation) // 2
    text = f"{'=' * side_length} {language} {'=' * side_length}"
    print(text)
